Hash Extender
By Ron Bowes <ron@skullsecurity.net>

+-------+
| INTRO |
+-------+
Awhile back, me and my friend @mak_kolybabi were doing a capture-the-flag contest at
https://stripe-ctf.com. One of the levels of the contest required us to perform
a hash length extension attack. I had never even heard of the attack at the
time, and after some reading I realized that not only is it a super cool (and
easy!) attack to perform, there is also a total lack of good tools for
performing said attack! After hours of adding the wrong number of null bytes
or incorrectly adding length values, I vowed to write a tool to make this easy for
myself and anybody else who's trying to do it. So, after a couple weeks of work, here
it is!

Now I'm gonna release the tool, and hope I didn't totally miss a good tool that does
the same thing :)

hash_extender implements a length extension attack against every algorithm I could
think of:
<ul>
  <li>md4</li>
  <li>md5</li>
  <li>ripemd160</li>
  <li>sha</li>
  <li>sha1</li>
  <li>sha256</li>
  <li>sha512</li>
  <li>whirlpool</li>
</li>

I'm more than happy to extend this to cover other hashtypes as well, provided
they are "vulnerable" to this attack. Please contact me if you have other
candidates and I'll add them ASAP!

+------------+
| THE ATTACK |
+------------+
An application is susceptible to a hash length extension attack if it
prepends a secret value to a string, hashes it with a vulnerable algorithm, and
entrusts the user with the string and the hash, but not the secret. The attacker
can append any amount of data to the string without knowing the secret, and still
generate a valid hash! This is done by simply picking up where the hashing algorithm
left off; it turns out, 100% of the context needed to continue a hash is in the
output of most hashing algorithms! We simply load that context into the appropriate
hash structure and continue hashing.

TL;DR: given data with an unknown prefix and a hash, an attacker can
append to the data and still generate a valid signature.

+---------+
| EXAMPLE |
+---------+
Let's look at a step-by-step example. For this example:
<ul>
  <li>let secret = "secret"</li>
  <li>let data   = "data"</li>
  <li>let H = md5</li>
  <li>let signature = hash(secret + data) = "6036708eba0d11f6ef52ad44e8b74d5b"</li>
  <li>let append = "append"</li>
</ul>

The server sends <em>data</em> and <em>signature</em> to the attacker. The
attacker guesses that <em>H</em> is md5 simply by length (it's the most common
128-bit hashing algorithm), based on the source, or the specs, or any way
they are able to.

Knowing only <em>data</em>, <em>H</em>, and <em>signature</em>, the attacker's
goal is to append <em>append</em> to <em>data<em> and generate a valid signature
for the new data. And that's easy to do! Let's see how.

  +---------+
  | PADDING |
  +---------+
Before we look at the actual attack, we have to talk a little about padding.

When calculating <em>H</em>(<em>secret</em> + <em>data</em>), the string being
hashed is first padded with a '1' bit and a number of '0' bits. That is, in hex,
the 0x80 byte followed by some number of 0x00 bytes. The number of 0x00 bytes
depends on the particular algorithm and blocksize. With md4, md5, sha1, sha256,
and several other algorithms pad the string until it's congruent to 56 bytes
(mod 64). In other words, it's padded until (<em>length</em> mod 64) = 56. Or,
to put it one more way, it's padded until it's 8 bytes less than a full (64-byte)
block. sha512 and Whirlpool use a 128-bit blocksize and different modulus
values.

The final 8 bytes of the last block are set to the length, in bits, of the
original string. In md4, md5, and ripemd160, these are in little endian byte
order; in the sha family and whirlpool, they're big endian. Trust me, that
distinction cost me days of work!

In our example, <em>secret</em> + <em>data</em> = "secretdata" = 10 (0x0a) bytes,
or 80 (0x50) bits. That means we need 46 bytes of padding (80 00 00 00 00 ...)
followed by our 8-byte little endian length (50 00 00 00 00 00 00 00), giving us
a padded string of:
<pre>
  0000  73 65 63 72 65 74 64 61 74 61 80 00 00 00 00 00  secretdata......
  0010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  0020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  0030  00 00 00 00 00 00 00 00 50 00 00 00 00 00 00 00  ........P.......
</pre>

Breaking down the string, we have:
- "secret" = <em>secret</em>
- "data" = <em>data</em>
- 80 00 00 ... - The 46 bytes of padding, starting with 0x80
- 50 00 00 00 00 00 00 00 - The bit length in little endian

This is the exact data that <em>H</em> hashes.

  +------------+
  | THE ATTACK |
  +------------+
Now that we have the data that <em>H</em> hashes, let's look at how to perform
the actual attack.

First, let's just append <em>append</em> to the string. Easy enough! Here's
what it looks like:
<pre>
  0000  73 65 63 72 65 74 64 61 74 61 80 00 00 00 00 00  secretdata......
  0010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  0020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  0030  00 00 00 00 00 00 00 00 50 00 00 00 00 00 00 00  ........P.......
  0040  61 70 70 65 6e 64                                append
</pre>

The value of that block of data can be calculated in two ways:
<ol>
  <li>By sticking it in a buffer and performing <em>H(buffer)</em></li>
  <li>By starting at the end of the first block, using the state we already
      know from the original hash, and hashing <em>append</em> starting at
      that state</li>
</ol>

The first method is what the server will do, and the second is what the
attacker will do. Let's look at the server, first, since it's the easier
example.

We know the server will prepend <em>secret</em> to the string, so we send it
the string minus the <em>secret</em> value:
<pre>
  0000  64 61 74 61 80 00 00 00 00 00 00 00 00 00 00 00  data............
  0010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  0020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  0030  00 00 50 00 00 00 00 00 00 00 61 70 70 65 6e 64  ..P.......append
</pre>

Don't be fooled by this being exactly 64 bytes (the blocksize) - that's only
happening because <em>secret</em> and <em>append</em> are the same length.

The server will prepend <em>secret</em> to that string and hash it to the
following value:
6ee582a1669ce442f3719c47430dadee

For those of you playing along at home, you can prove this works by copying
and pasting this into a terminal:
<pre>
echo '
#include <stdio.h>
#include <openssl/md5.h>

int main(int argc, const char *argv[])
{
  MD5_CTX c;
  unsigned char buffer[MD5_DIGEST_LENGTH];
  int i;

  MD5_Init(&c);
  MD5_Update(&c, "secret", 6);
  MD5_Update(&c, "data", 4);
  MD5_Update(&c, "\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                 "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                 "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                 "\x00\x00\x00\x00", 46);
  MD5_Update(&c, "\x50\x00\x00\x00\x00\x00\x00\x00", 8);
  MD5_Update(&c, "append", 6);
  MD5_Final(buffer, &c);

  for (i = 0; i < 16; i++) {
    printf("%02x", buffer[i]);
  }
  printf("\n");
  return 0;
}' > hash_extension_1.c
gcc -lssl -lcrypto -o hash_extension_1 hash_extension_1.c
./hash_extension_1
</pre>

All right, so the server is going to be checking the data we send against the
signature "6ee582a1669ce442f3719c47430dadee". Now, as the attacker, we need to
figure out how to generate that signature!

Well, first, we have to look at what we have: the data, the appended data, and
the output of the hash function. It turns out, the output from any of these
hash functions is nearly the entire state, and is alllllmost enough information
to re-create it completely. The only thing we don't have is the length, because
we don't know the length of 'secret'. It turns out, however, that the length
doesn't usually matter (unless it's close to a block boundary).

Basically, we want to create a md5 context, ensure that the hash's length is
appropriate, then replace the current state with the state from the
the final state of the original hash, The code to do this is basically:

<pre>
  unsigned char buffer[MD5_DIGEST_LENGTH];
  MD5_CTX c;
  MD5_Init(&c);
  MD5_Update(&c, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA", 64);
  c.A = ntonl(0x6036708e); /* <-- This is the hash we already had */
  c.B = ntonl(0xba0d11f6);
  c.C = ntonl(0xef52ad44);
  c.D = ntonl(0xe8b74d5b);
  MD5_Update(&c, "append", 6); /* This is the appended data. */
  MD5_Final(buffer, &c);
</pre>

The the output is, just like before:
6ee582a1669ce442f3719c47430dadee

So, now we have this string:
data%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%50%00%00%00%00%00%00%00append

And this signature:
6ee582a1669ce442f3719c47430dadee

Which can be generated legitimately, with the secret, and also without the
secret by replacing the state!

+----------+
| THE TOOL |
+----------+
When I wrote this example, I screwed up the code about 1000 times with the
wrong sizes, or values, or endianness, or various other problems. It's
ridiculous! So, I wrote a tool that abstracts everything. You give it the
original data, the length of the signature, and what you want to append, and it
spits out the new data and the new signature.

Here's an example of its use:
$ ./hash_extender --data data --secret 6 --append append --signature 6036708eba0d11f6ef52ad44e8b74d5b --out-data-format html --format md5
Type: md5
Secret length: 6
New signature: 6ee582a1669ce442f3719c47430dadee
New string: data%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00P%00%00%00%00%00%00%00append

If you're unsure about the hash type, you can let it try different types by
leaving off the --format argument. I recommend using the --table argument as
well:

$ ./hash_extender --data data --secret 6 --append append --signature 6036708eba0d11f6ef52ad44e8b74d5b --out-data-format html --table
md4       89df68618821cd4c50dfccd57c79815b data%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00P%00%00%00%00%00%00%00append
md5       6ee582a1669ce442f3719c47430dadee data%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00P%00%00%00%00%00%00%00append


|------------------------------------------------------------------------------|








