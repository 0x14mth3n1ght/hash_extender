Hash Extender
By Ron Bowes <ron@skullsecurity.net>

This will be a blog post on http://www.skullsecurity.org/. For now, it's a
REAME file.

<h1>Intro</h1>

Awhile back, me and my friend @mak_kolybabi were doing a capture-the-flag
contest at https://stripe-ctf.com. One of the levels of the contest required us
to perform a hash length extension attack. I had never even heard of the attack
at the time, and after some reading I realized that not only is it a super cool
(and easy!) attack to perform, there is also a total lack of good tools for
performing said attack! After hours of adding the wrong number of null bytes or
incorrectly adding length values, I vowed to write a tool to make this easy for
myself and anybody else who's trying to do it. So, after a couple weeks of
work, here it is!

Now I'm gonna release the tool, and hope I didn't totally miss a good tool that
does the same thing :)

hash_extender implements a length extension attack against every algorithm I
could think of:

<ul>
  <li>md4</li>
  <li>md5</li>
  <li>ripemd160</li>
  <li>sha</li>
  <li>sha1</li>
  <li>sha256</li>
  <li>sha512</li>
  <li>whirlpool</li>
</li>

I'm more than happy to extend this to cover other hashtypes as well, provided
they are "vulnerable" to this attack. Please contact me if you have other
candidates and I'll add them ASAP!

<h1>The attack</h1>

An application is susceptible to a hash length extension attack if it prepends
a secret value to a string, hashes it with a vulnerable algorithm, and entrusts
the attacker with both the string and the hash, but not the secret. Then, the
server relies on the secret to decide whether or not the data returned later is
the same as the original data.

It turns out, even though the attacker doesn't know the value of the prepended
secret, he can still generate a valid hash for (secret + data +
attacker_controlled_data)! This is done by simply picking up where the hashing
algorithm left off; it turns out, 100% of the context needed to continue a hash
is in the output of most hashing algorithms! We simply load that context into
the appropriate hash structure and continue hashing.

TL;DR: given data with an unknown prefix and a hash, an attacker can append to
the data and still generate a valid signature.

<h1>Example</h1>

Let's look at a step-by-step example. For this example:

<ul>
  <li>let secret = "secret"</li>
  <li>let data   = "data"</li>
  <li>let H = md5</li>
  <li>let signature = hash(secret + data) = "6036708eba0d11f6ef52ad44e8b74d5b"</li>
  <li>let append = "append"</li>
</ul>

The server sends <em>data</em> and <em>signature</em> to the attacker. The
attacker guesses that <em>H</em> is md5 simply by its length (it's the most
common 128-bit hashing algorithm), based on the source, or the specs, or any
way they are able to.

Knowing only <em>data</em>, <em>H</em>, and <em>signature</em>, the attacker's
goal is to append <em>append</em> to <em>data</em> and generate a valid
signature for the new data. And that's easy to do! Let's see how.

<h2>Padding</h2>
Before we look at the actual attack, we have to talk a little about padding.

When calculating <em>H</em>(<em>secret</em> + <em>data</em>), the string
(<em>secret</em> + <em>data</em>) is padded with a '1' bit and some number of
'0' bits, followed by the length of the string. That is, in hex, the padding is
a 0x80 byte followed by some number of 0x00 bytes and then the length.  The
number of 0x00 bytes, the number of bytes reserved for the length, and the way
the length is encoded depends on the particular algorithm and blocksize.

With most algorithms (including md4, md5, sha1, and sha256), the string is
padded until its length is congruent to 56 bytes (mod 64) Or, to put it another
way, it's padded until the length is 8 bytes less than a full (64-byte) block
(the 8 bytes being size of the encoded length field). There are two hashes
implemented in hash_extender that don't use these values: sha512 uses a
128-byte blocksize and reserves 16 bytes for the length field, and whirlpool uses a
128-byte blocksdize and reserves 32 bytes for the length field.

The endianness of the length field is also important. md4, md5, and ripemd160
are little endian, whereas the sha family and whirlpool are big endian. Trust
me, that distinction cost me days of work!

In our example, length(<em>secret</em> + <em>data</em>) = length("secretdata")
= 10 (0x0a) bytes, or 80 (0x50) bits. So, we have 10 bytes of data
("secretdata"), 46 bytes of padding (80 00 00 ...), and an 8-byte little endian
length field (50 00 00 00 00 00 00 00), for a total of 64 bytes (or one block).
Put together, it looks like this:

<pre>
  0000  73 65 63 72 65 74 64 61 74 61 80 00 00 00 00 00  secretdata......
  0010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  0020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  0030  00 00 00 00 00 00 00 00 50 00 00 00 00 00 00 00  ........P.......
</pre>

Breaking down the string, we have:

<ul>
  <li>"secret" = <em>secret</em></li>
  <li>"data" = <em>data</em></li>
  <li>80 00 00 ... - The 46 bytes of padding, starting with 0x80</li>
  <li>50 00 00 00 00 00 00 00 - The bit length in little endian</li>
</ul>

This is the exact data that <em>H</em> hashes.

  +------------+
  | THE ATTACK |
  +------------+

Now that we have the data that <em>H</em> hashes, let's look at how to perform
the actual attack.

First, let's just append <em>append</em> to the string. Easy enough! Here's
what it looks like:

<pre>
  0000  73 65 63 72 65 74 64 61 74 61 80 00 00 00 00 00  secretdata......
  0010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  0020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  0030  00 00 00 00 00 00 00 00 50 00 00 00 00 00 00 00  ........P.......
  0040  61 70 70 65 6e 64                                append
</pre>

The value of that block of data can be calculated in two ways:

<ol>
  <li>By sticking it in a buffer and performing <em>H(buffer)</em></li>
  <li>By starting at the end of the first block, using the state we already
      know from <em>signature</em>, and hashing <em>append</em> starting at
      that state</li>
</ol>

The first method is what the server will do, and the second is what the
attacker will do. Let's look at the server, first, since it's the easier
example.

<h3>Server's calculation</h3>

We know the server will prepend <em>secret</em> to the string, so we send it
the string minus the <em>secret</em> value:

<pre>
  0000  64 61 74 61 80 00 00 00 00 00 00 00 00 00 00 00  data............
  0010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  0020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  0030  00 00 50 00 00 00 00 00 00 00 61 70 70 65 6e 64  ..P.......append
</pre>

Don't be fooled by this being exactly 64 bytes (the blocksize) - that's only
happening because <em>secret</em> and <em>append</em> are the same length.
Perhaps I shouldn't have chosen that as an example, but I'm not gonna start
over!

The server will prepend <em>secret</em> to that string and hash it to the
following value:

6ee582a1669ce442f3719c47430dadee

For those of you playing along at home, you can prove this works by copying and
pasting this into a terminal:

<pre>
echo '
#include <stdio.h>
#include <openssl/md5.h>

int main(int argc, const char *argv[])
{
  MD5_CTX c;
  unsigned char buffer[MD5_DIGEST_LENGTH];
  int i;

  MD5_Init(&amp;c);
  MD5_Update(&amp;c, "secret", 6);
  MD5_Update(&amp;c, "data"
                 "\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                 "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                 "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                 "\x00\x00\x00\x00"
                 "\x50\x00\x00\x00\x00\x00\x00\x00"
                 "append", 64);
  MD5_Final(buffer, &amp;c);

  for (i = 0; i &lt; 16; i++) {
    printf("%02x", buffer[i]);
  }
  printf("\n");
  return 0;
}' > hash_extension_1.c
gcc -o hash_extension_1 hash_extension_1.c -lssl -lcrypto
./hash_extension_1

</pre>

All right, so the server is going to be checking the data we send against the
signature "6ee582a1669ce442f3719c47430dadee". Now, as the attacker, we need to
figure out how to generate that signature!

<h3>Client's calculation</h3>
So, how do we calculate the hash of the data shown above without actually
having access to <em>secret</em>?

Well, first, we have to look at what we have: <em>data</em>, <em>append</em>,
<em>H</em> and <em>H</em>(<em>secret</em>+<em>data</em>).

We need to define a new function, <em>H&prime;</em>, which uses the same
hashing algorithm as <em>H</em>, but whose starting state is the final state of
<em>H</em>(<em>secret</em>+<em>data</em>).

Then, we simply calculate <em>H&prime;</em>(<em>append</em>) and the output of
that function is our hash. It sounds easy (and is!); have a look at this code:

<pre>
echo '
#include <stdio.h>
#include <openssl/md5.h>

int main(int argc, const char *argv[])
{
  int i;
  unsigned char buffer[MD5_DIGEST_LENGTH];
  MD5_CTX c;
  MD5_Init(&amp;c);
  MD5_Update(&amp;c, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA", 64);

  c.A = htonl(0x6036708e); /* <-- This is the hash we already had */
  c.B = htonl(0xba0d11f6);
  c.C = htonl(0xef52ad44);
  c.D = htonl(0xe8b74d5b);

  MD5_Update(&c, "append", 6); /* This is the appended data. */
  MD5_Final(buffer, &c);
  for (i = 0; i &lt; 16; i++) {
    printf("%02x", buffer[i]);
  }
  printf("\n");
  return 0;
}' > hash_extension_2.c
gcc -o hash_extension_2 hash_extension_2.c -lssl -lcrypto
./hash_extension_2
</pre>

The the output is, just like before:

6ee582a1669ce442f3719c47430dadee

So we know the signature is right. What's happening!?

Well, we create a MD5_CTX structure from scratch, just like normal. Then we
take the md5() value of 64 'A's. We md5() a full (64-byte) block of 'A's to
ensure that any internal values - other than the state of the hash itself - are
set to what we expect.

Then, after that is done, we replace c.A, c.B, c.C, and c.D with the values
that were output from <em>signature</em>: "6036708eba0d11f6ef52ad44e8b74d5b".
This puts the MD5_CTX structure in the same state as it finished in originally,
and means that anything else we hash - in this case <em>append</em> - will
result in the same thing as it would have resulted in, had we hashed it the
usual way.

    +--------+
    | RESULT |
    +--------+

So, now we have this string:

<pre>
  0000  64 61 74 61 80 00 00 00 00 00 00 00 00 00 00 00  data............
  0010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  0020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  0030  00 00 50 00 00 00 00 00 00 00 61 70 70 65 6e 64  ..P.......append
</pre>

And this signature for <em>H</em>(<em>secret</em> + <em>data</em> +
<em>append</em>):

6ee582a1669ce442f3719c47430dadee

And we can generate both without ever knowing what the secret was!

<h1>The tool</h1>

This example took me hours to write. Why? Because I made about 1000 mistakes
writing the code. Too many 00 bytes, not enough 00 bytes, wrong endianness,
wrong algorithm, used bytes instead of bits for the length, and all sorts of
other problems. The first time I worked on this type of attack, I spent from
11pm till 7am trying to get it working, and didn't figure it out till after
sleeping. And don't even get me started on how long it took to port this attack
to md5.

Why?

Because this is crypto, and crypto is immensely complicated. There are lots of
moving parts, lots of sidecases to remember, and it's never clear why something
is wrong, just that the answer isn't right. What a pain!

So, I wrote hash_extender. hash_extender is (I hope) the first free tool that
implements this type of attack. It's easy to use

Here's an example of its use:

$ ./hash_extender --data data --secret 6 --append append \
  --signature 6036708eba0d11f6ef52ad44e8b74d5b --format md5
Type: md5
Secret length: 6
New signature: 6ee582a1669ce442f3719c47430dadee
New string: 64617461800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000617070656e64

If you're unsure about the hash type, you can let it try different types by
leaving off the --format argument. I recommend using the --table argument as
well if you're doing anything with multiple :

$ ./hash_extender --data data --secret 6 --append append --signature 6036708eba0d11f6ef52ad44e8b74d5b --out-data-format html --table
md4       89df68618821cd4c50dfccd57c79815b data80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000P00000000000000append
md5       6ee582a1669ce442f3719c47430dadee data80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000P00000000000000append

There are plenty of options for how you format inputs and outputs, including
HTML (where you use %NN notation), CString (where you use \xNN notation, as
well as \r, \n, \t, etc.), hex (such as how the hashes were specified above),
etc.

By default I tried to choose the most reasonable options:

<ul>
  <li>Input data: raw</li>
  <li>Input hash: hex</li>
  <li>Output data: hex</li>
  <li>Output hash: hex</li>
</ul>

<h1>Defense</h1>

So, as a programmer, how do you solve this?

It's actually pretty simple. There are two ways:

<ol>
  <ul>Don't trust a user with encrypted data or signatures, if you can avoid it.</ul>
  <ul>If you can't avoid it, then use HMAC() instead of trying to do it yourself. HMAC is designed for this.</ul>
</ol>

HMAC() is the real solution. HMAC() is designed for securely hashing data based
on a secret key.

As usual, use constructs designed for what you're doing rather than doing it
yourself. The key to all crypto!

