Hash Extender
By Ron Bowes <ron@skullsecurity.net>

+-------+
| INTRO |
+-------+
Awhile back, me and my friend @mak_kolybabi were doing a capture-the-flag contest at
https://stripe-ctf.com. One of the levels of the contest required us to perform
a hash length extension attack. I had never even heard of the attack at the
time, and after some reading I realized that not only is it a super cool (and
easy!) attack to perform, there is also a total lack of good tools for
performing said attack! After hours of adding the wrong number of null bytes
or incorrectly adding length values, I vowed to write a tool to make this easy for
myself and anybody else who's trying to do it. So, after a couple weeks of work, here
it is!

Now I'm gonna release the tool, and hope I didn't totally miss a good tool that does
the same thing :)

hash_extender implements a length extension attack against every algorithm I could
think of:
<ul>
  <li>md4</li>
  <li>md5</li>
  <li>ripemd160</li>
  <li>sha</li>
  <li>sha1</li>
  <li>sha256</li>
  <li>sha512</li>
  <li>whirlpool</li>
</li>

I'm more than happy to extend this to cover other hashtypes as well, provided
they are "vulnerable" to this attack. Please contact me if you have other
candidates and I'll add them ASAP!

+------------+
| THE ATTACK |
+------------+
An application is susceptible to a hash length extension attack if it
prepends a secret value to a string, hashes it with a vulnerable algorithm, and
entrusts the user with the string and the hash, but not the secret. The attacker
can append any amount of data to the string without knowing the secret, and still
generate a valid hash! This is done by simply picking up where the hashing algorithm
left off; it turns out, 100% of the context needed to continue a hash is in the
output of most hashing algorithms! We simply load that context into the appropriate
hash structure and continue hashing.

TL;DR: given data with an unknown prefix and a hash, an attacker can
append to the data and still generate a valid signature.

+---------+
| EXAMPLE |
+---------+
Let's look at a step-by-step example. For this example:
<ul>
  <li>let secret = "secret"</li>
  <li>let data   = "data"</li>
  <li>let H = md5</li>
  <li>let signature = hash(secret + data) = "6036708eba0d11f6ef52ad44e8b74d5b"</li>
  <li>let append = "append"</li>
</ul>

The server sends <em>data</em> and <em>signature</em> to the attacker. The
attacker guesses that <em>H</em> is md5 simply by length (it's the most common
128-bit hashing algorithm), based on the source, or the specs, or any way
they are able to.

Knowing only <em>data</em>, <em>H</em>, and <em>signature</em>, the attacker's
goal is to append <em>append</em> to <em>data<em> and generate a valid signature
for the new data. And that's easy to do! Let's see how.

  +---------+
  | PADDING |
  +---------+
Before we look at the actual attack, we have to talk a little about padding.

When calculating <em>H</em>(<em>secret</em> + <em>data</em>), the string being
hashed is first padded with a '1' bit and a number of '0' bits. That is, in hex,
the 0x80 byte followed by some number of 0x00 bytes. The number of 0x00 bytes
depends on the particular algorithm and blocksize. With md4, md5, sha1, sha256,
and several other algorithms pad the string until it's congruent to 56 bytes
(mod 64). In other words, it's padded until (<em>length</em> mod 64) = 56. Or,
to put it one more way, it's padded until it's 8 bytes less than a full (64-byte)
block. sha512 and Whirlpool use a 128-bit blocksize and different modulus
values.

The final 8 bytes of the last block are set to the length, in bits, of the
original string. In md4, md5, and ripemd160, these are in little endian byte
order; in the sha family and whirlpool, they're big endian. Trust me, that
distinction cost me days of work!

In our example, <em>secret</em> + <em>data</em> = "secretdata" = 10 (0x0a) bytes,
or 80 (0x50) bits. That means we need 46 bytes of padding (80 00 00 00 00 ...)
followed by our 8-byte little endian length (50 00 00 00 00 00 00 00), giving us
a padded string of:
<pre>secretdata%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%50%00%00%00%00%00%00%00</pre>

TODO: make this pretty

That's the exact data that was hashed, which means we know the md5 of that exact
string. Let's break it up into what each part means:
To break it up:
- "secret" - the original secret.
- "data" - the original data.
- "%80"  - the leading '1' bit for the padding.
- "%00" * 45 - Enough padding that "secretdata" + padding = 56 bytes.
- "%50%00%00%00%00%00%00%00" - The length, in bits, of the original data (10 *
  8 = 80 = 0x50), encoded in little endian.

Let's call that string "pdata", for the sake of simpilicity.

Our goal is to add "append" to the string, then calculate md5(pdata + append).
It turns out, that's possible without knowing "secret"!

First, the value we're going to send to the server will be pdata without the
"secret" value and with "append" appended::
data%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%50%00%00%00%00%00%00%00append

The server will prepend "secret" and attempt to hash it as:
secretdata%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%50%00%00%00%00%00%00%00append

And wind up with:
6ee582a1669ce442f3719c47430dadee

You can test it with the following code:
<pre>
  int main(int argc, const char *argv[])
  {
    MD5_CTX c;
    unsigned char buffer[MD5_DIGEST_LENGTH];
    int i;

    MD5_Init(&c);
    MD5_Update(&c, "secret", 6);
    MD5_Update(&c, "data", 4);
    MD5_Update(&c, "\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                   "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                   "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                   "\x00\x00\x00\x00", 46);
    MD5_Update(&c, "\x50\x00\x00\x00\x00\x00\x00\x00", 8);
    MD5_Update(&c, "append", 6);
    MD5_Final(buffer, &c);

    for (i = 0; i < 16; i++) {
      printf("%02x", buffer[i]);
    }
    printf("\n");
    return 0;
  }
</pre>

Now, that's the signature that the server generates. How do *we* generate it?

Well, first, we have to look at what we have: the data, the appended data, and
the output of the hash function. It turns out, the output from any of these
hash functions is nearly the entire state, and is alllllmost enough information
to re-create it completely. The only thing we don't have is the length, because
we don't know the length of 'secret'. It turns out, however, that the length
doesn't usually matter (unless it's close to a block boundary).

Basically, we want to create a md5 context, ensure that the hash's length is
appropriate, then replace the current state with the state from the
the final state of the original hash, The code to do this is basically:

<pre>
  unsigned char buffer[MD5_DIGEST_LENGTH];
  MD5_CTX c;
  MD5_Init(&c);
  MD5_Update(&c, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA", 64);
  c.A = ntonl(0x6036708e); /* <-- This is the hash we already had */
  c.B = ntonl(0xba0d11f6);
  c.C = ntonl(0xef52ad44);
  c.D = ntonl(0xe8b74d5b);
  MD5_Update(&c, "append", 6); /* This is the appended data. */
  MD5_Final(buffer, &c);
</pre>

The the output is, just like before:
6ee582a1669ce442f3719c47430dadee

So, now we have this string:
data%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%50%00%00%00%00%00%00%00append

And this signature:
6ee582a1669ce442f3719c47430dadee

Which can be generated legitimately, with the secret, and also without the
secret by replacing the state!

+----------+
| THE TOOL |
+----------+
When I wrote this example, I screwed up the code about 1000 times with the
wrong sizes, or values, or endianness, or various other problems. It's
ridiculous! So, I wrote a tool that abstracts everything. You give it the
original data, the length of the signature, and what you want to append, and it
spits out the new data and the new signature.

Here's an example of its use:
$ ./hash_extender --data data --secret 6 --append append --signature 6036708eba0d11f6ef52ad44e8b74d5b --out-data-format html --format md5
Type: md5
Secret length: 6
New signature: 6ee582a1669ce442f3719c47430dadee
New string: data%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00P%00%00%00%00%00%00%00append

If you're unsure about the hash type, you can let it try different types by
leaving off the --format argument. I recommend using the --table argument as
well:

$ ./hash_extender --data data --secret 6 --append append --signature 6036708eba0d11f6ef52ad44e8b74d5b --out-data-format html --table
md4       89df68618821cd4c50dfccd57c79815b data%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00P%00%00%00%00%00%00%00append
md5       6ee582a1669ce442f3719c47430dadee data%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00P%00%00%00%00%00%00%00append


|------------------------------------------------------------------------------|








