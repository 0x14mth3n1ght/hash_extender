Hash Extender
By Ron Bowes <ron@skullsecurity.net>

This will be a blog post on http://www.skullsecurity.org/. For now, it's a
README file.

<h1>Intro</h1>

Awhile back, me and my friend @mak_kolybabi were doing a capture-the-flag
contest at https://stripe-ctf.com. One of the levels of the contest required us
to perform a hash length extension attack. I had never even heard of the attack
at the time, and after some reading I realized that not only is it a super cool
(and conceptually easy!) attack to perform, there is also a total lack of good
tools for performing said attack! After hours of adding the wrong number of
null bytes or incorrectly adding length values, I vowed to write a tool to make
this easy for myself and anybody else who's trying to do it. So, after a couple
weeks of work, here it is!

Now I'm gonna release the tool, and hope I didn't totally miss a good tool that
does the same thing! It's called hash_extender, and implements a length
extension attack against every algorithm I could think of:

<ul>
  <li>md4</li>
  <li>md5</li>
  <li>ripemd160</li>
  <li>sha</li>
  <li>sha1</li>
  <li>sha256</li>
  <li>sha512</li>
  <li>whirlpool</li>
</li>

I'm more than happy to extend this to cover other hashtypes as well, provided
they are "vulnerable" to this attack. Please contact me if you have other
candidates and I'll add them ASAP!

<h1>The attack</h1>

An application is susceptible to a hash length extension attack if it prepends
a secret value to a string, hashes it with a vulnerable algorithm, and entrusts
the attacker with both the string and the hash, but not the secret. Then, the
server relies on the secret to decide whether or not the data returned later is
the same as the original data.

It turns out, even though the attacker doesn't know the value of the prepended
secret, he can still generate a valid hash for (secret + data +
attacker_controlled_data)! This is done by simply picking up where the hashing
algorithm left off; it turns out, 100% of the context needed to continue a hash
is in the output of most hashing algorithms! We simply load that context into
the appropriate hash structure and continue hashing.

TL;DR: given known data with an unknown prefix and a known hash, an attacker
can append to the data and still generate a valid signature.

<h1>Example</h1>

Let's look at a step-by-step example. For this example:

<ul>
  <li>let <em>secret</em>    = "secret"</li>
  <li>let <em>data</em>      = "data"</li>
  <li>let <em>H</em>         = md5()</li>
  <li>let <em>signature</em> = hash(<em>secret</em> + <em>data</em>) = "6036708eba0d11f6ef52ad44e8b74d5b"</li>
  <li>let <em>append</em>    = "append"</li>
</ul>

The server sends <em>data</em> and <em>signature</em> to the attacker. The
attacker guesses that <em>H</em> is md5 simply by its length (it's the most
common 128-bit hashing algorithm), based on the source, or the application's
specs, or any way they are able to.

Knowing only <em>data</em>, <em>H</em>, and <em>signature</em>, the attacker's
goal is to append <em>append</em> to <em>data</em> and generate a valid
signature for the new data. And that's easy to do! Let's see how.

<h2>Padding</h2>

Before we look at the actual attack, we have to talk a little about padding.

When calculating <em>H</em>(<em>secret</em> + <em>data</em>), the string
(<em>secret</em> + <em>data</em>) is padded with a '1' bit and some number of
'0' bits, followed by the length of the string. That is, in hex, the padding is
a 0x80 byte followed by some number of 0x00 bytes and then the length.  The
number of 0x00 bytes, the number of bytes reserved for the length, and the way
the length is encoded, depends on the particular algorithm and blocksize.

With most algorithms (including md4, md5, ripemd160, sha, sha1, and sha256),
the string is padded until its length is congruent to 56 bytes (mod 64) Or, to
put it another way, it's padded until the length is 8 bytes less than a full
(64-byte) block (the 8 bytes being size of the encoded length field). There are
two hashes implemented in hash_extender that don't use these values: sha512
uses a 128-byte blocksize and reserves 16 bytes for the length field, and
whirlpool uses a 128-byte blocksize and reserves 32 bytes for the length field.

The endianness of the length field is also important. md4, md5, and ripemd160
are little endian, whereas the sha family and whirlpool are big endian. Trust
me, that distinction cost me days of work!

In our example, length(<em>secret</em> + <em>data</em>) = length("secretdata")
= 10 (0x0a) bytes, or 80 (0x50) bits. So, we have 10 bytes of data
("secretdata"), 46 bytes of padding (80 00 00 ...), and an 8-byte little endian
length field (50 00 00 00 00 00 00 00), for a total of 64 bytes (or one block).
Put together, it looks like this:

<pre>
  0000  73 65 63 72 65 74 64 61 74 61 80 00 00 00 00 00  secretdata......
  0010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  0020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  0030  00 00 00 00 00 00 00 00 50 00 00 00 00 00 00 00  ........P.......
</pre>

Breaking down the string, we have:

<ul>
  <li>"secret" = <em>secret</em></li>
  <li>"data" = <em>data</em></li>
  <li>80 00 00 ... - The 46 bytes of padding, starting with 0x80</li>
  <li>50 00 00 00 00 00 00 00 - The bit length in little endian</li>
</ul>

This is the exact data that <em>H</em> hashed in the original example.

<h2>The attack</h2>

Now that we have the data that <em>H</em> hashes, let's look at how to perform
the actual attack.

First, let's just append <em>append</em> to the string. Easy enough! Here's
what it looks like:

<pre>
  0000  73 65 63 72 65 74 64 61 74 61 80 00 00 00 00 00  secretdata......
  0010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  0020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  0030  00 00 00 00 00 00 00 00 50 00 00 00 00 00 00 00  ........P.......
  0040  61 70 70 65 6e 64                                append
</pre>

The hash of that block is what we ultimately want to a) calculate, and b) get
the server to calculate. The value of that block of data can be calculated in
two ways:

<ol>
  <li>By sticking it in a buffer and performing <em>H(buffer)</em></li>
  <li>By starting at the end of the first block, using the state we already
      know from <em>signature</em>, and hashing <em>append</em> starting at
      that state</li>
</ol>

The first method is what the server will do, and the second is what the
attacker will do. Let's look at the server, first, since it's the easier
example.

<h3>Server's calculation</h3>

We know the server will prepend <em>secret</em> to the string, so we send it
the string minus the <em>secret</em> value:

<pre>
  0000  64 61 74 61 80 00 00 00 00 00 00 00 00 00 00 00  data............
  0010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  0020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  0030  00 00 50 00 00 00 00 00 00 00 61 70 70 65 6e 64  ..P.......append
</pre>

Don't be fooled by this being exactly 64 bytes (the blocksize) - that's only
happening because <em>secret</em> and <em>append</em> are the same length.
Perhaps I shouldn't have chosen that as an example, but I'm not gonna start
over!

The server will prepend <em>secret</em> to that string, creating:
<pre>
  0000  73 65 63 72 65 74 64 61 74 61 80 00 00 00 00 00  secretdata......
  0010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  0020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  0030  00 00 00 00 00 00 00 00 50 00 00 00 00 00 00 00  ........P.......
  0040  61 70 70 65 6e 64                                append
</pre>


And hashes it to the following value:

6ee582a1669ce442f3719c47430dadee

For those of you playing along at home, you can prove this works by copying and
pasting this into a terminal:

<pre>
echo '
#include &lt;stdio.h&gt;
#include &lt;openssl/md5.h&gt;

int main(int argc, const char *argv[])
{
  MD5_CTX c;
  unsigned char buffer[MD5_DIGEST_LENGTH];
  int i;

  MD5_Init(&amp;c);
  MD5_Update(&amp;c, "secret", 6);
  MD5_Update(&amp;c, "data"
                 "\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                 "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                 "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                 "\x00\x00\x00\x00"
                 "\x50\x00\x00\x00\x00\x00\x00\x00"
                 "append", 64);
  MD5_Final(buffer, &amp;c);

  for (i = 0; i &lt; 16; i++) {
    printf("%02x", buffer[i]);
  }
  printf("\n");
  return 0;
}' &gt; hash_extension_1.c
gcc -o hash_extension_1 hash_extension_1.c -lssl -lcrypto
./hash_extension_1

</pre>

All right, so the server is going to be checking the data we send against the
signature "6ee582a1669ce442f3719c47430dadee". Now, as the attacker, we need to
figure out how to generate that signature!

<h3>Client's calculation</h3>
So, how do we calculate the hash of the data shown above without actually
having access to <em>secret</em>?

Well, first, we have to look at what we have: <em>data</em>, <em>append</em>,
<em>H</em> and <em>H</em>(<em>secret</em>+<em>data</em>).

We need to define a new function, <em>H&prime;</em>, which uses the same
hashing algorithm as <em>H</em>, but whose starting state is the final state of
<em>H</em>(<em>secret</em>+<em>data</em>), ie, <em>signature</em>.

Then, we simply calculate <em>H&prime;</em>(<em>append</em>) and the output of
that function is our hash. It sounds easy (and is!); have a look at this code:

<pre>
echo '
#include &lt;stdio.h&gt;
#include &lt;openssl/md5.h&gt;

int main(int argc, const char *argv[])
{
  int i;
  unsigned char buffer[MD5_DIGEST_LENGTH];
  MD5_CTX c;
  MD5_Init(&amp;c);
  MD5_Update(&amp;c, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA", 64);

  c.A = htonl(0x6036708e); /* &lt;-- This is the hash we already had */
  c.B = htonl(0xba0d11f6);
  c.C = htonl(0xef52ad44);
  c.D = htonl(0xe8b74d5b);

  MD5_Update(&amp;c, "append", 6); /* This is the appended data. */
  MD5_Final(buffer, &amp;c);
  for (i = 0; i &lt; 16; i++) {
    printf("%02x", buffer[i]);
  }
  printf("\n");
  return 0;
}' &gt; hash_extension_2.c
gcc -o hash_extension_2 hash_extension_2.c -lssl -lcrypto
./hash_extension_2
</pre>

The the output is, just like before:

6ee582a1669ce442f3719c47430dadee

So we know the signature is right. The difference is, we didn't use
<em>secret</em> at all! What's happening!?

Well, we create a MD5_CTX structure from scratch, just like normal. Then we
take the md5() value of 64 'A's. We md5() a full (64-byte) block of 'A's to
ensure that any internal values - other than the state of the hash itself - are
set to what we expect.

Then, after that is done, we replace c.A, c.B, c.C, and c.D with the values
that were found in <em>signature</em>: "6036708eba0d11f6ef52ad44e8b74d5b".
This puts the MD5_CTX structure in the same state as it finished in originally,
and means that anything else we hash - in this case <em>append</em> - will
result in the same thing as it would have resulted in, had we hashed it the
usual way.

We use htonl() on the values before setting the state variables because md5 -
being little endian - outputs its values in litlte endian as well.

<h3>Result</h3>

So, now we have this string:

<pre>
  0000  64 61 74 61 80 00 00 00 00 00 00 00 00 00 00 00  data............
  0010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  0020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  0030  00 00 50 00 00 00 00 00 00 00 61 70 70 65 6e 64  ..P.......append
</pre>

And this signature for <em>H</em>(<em>secret</em> + <em>data</em> +
<em>append</em>):

6ee582a1669ce442f3719c47430dadee

And we can generate both without ever knowing what the secret was! So, we send
the string to the server along with our new signature. The server will prepend
the signature, hash it, and come up with the exact same hash we did (victory!).

<h1>The tool</h1>

This example took me hours to write. Why? Because I made about 1000 mistakes
writing the code. Too many 00 bytes, not enough 00 bytes, wrong endianness,
wrong algorithm, used bytes instead of bits for the length, and all sorts of
other stupid problems. The first time I worked on this type of attack, I spent
from 11pm till 7am trying to get it working, and didn't figure it out till
after sleeping (and with Mak's help). And don't even get me started on how long
it took to port this attack to md5. Endianness can die in a fire.

Why is it so difficult? Because this is crypto, and crypto is immensely
complicated and notoriously difficult to troubleshoot. There are lots of moving
parts, lots of sidecases to remember, and it's never clear why something is
wrong, just that the result isn't right. What a pain!

So, I wrote hash_extender. hash_extender is (I hope) the first free tool that
implements this type of attack. It's easy to use and implements this attack for
every algorithm I could think of.

Here's an example of its use:

$ ./hash_extender --data data --secret 6 --append append \
  --signature 6036708eba0d11f6ef52ad44e8b74d5b --format md5
Type: md5
Secret length: 6
New signature: 6ee582a1669ce442f3719c47430dadee
New string: 64617461800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000617070656e64

If you're unsure about the hash type, you can let it try different types by
leaving off the --format argument. I recommend using the --table argument as
well if you're doing anything with multiple :

$ ./hash_extender --data data --secret 6 --append append --signature 6036708eba0d11f6ef52ad44e8b74d5b --out-data-format html --table
md4       89df68618821cd4c50dfccd57c79815b data80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000P00000000000000append
md5       6ee582a1669ce442f3719c47430dadee data80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000P00000000000000append

There are plenty of options for how you format inputs and outputs, including
HTML (where you use %NN notation), CString (where you use \xNN notation, as
well as \r, \n, \t, etc.), hex (such as how the hashes were specified above),
etc.

By default I tried to choose the most reasonable options:

<ul>
  <li>Input data: raw</li>
  <li>Input hash: hex</li>
  <li>Output data: hex</li>
  <li>Output hash: hex</li>
</ul>

Here's the help page for reference:
<pre>
--------------------------------------------------------------------------------
HASH EXTENDER
--------------------------------------------------------------------------------

By Ron Bowes &lt;ron @ skullsecurity.net&gt;

See LICENSE.txt for license information.

Usage: ./hash_extender &lt;--data=&lt;data&gt;|--file=&lt;file&gt;&gt; --signature=&lt;signature&gt; --format=&lt;format&gt; [options]

INPUT OPTIONS
-d --data=&lt;data&gt;
      The original string that we're going to extend.
--data-format=&lt;raw|html|hex|cstr&gt;
      The format the string is being passed in as. Default: raw.
--file=&lt;file&gt;
      As an alternative to specifying a string, this reads the original string
      as a file.
-s --signature=&lt;sig&gt;
      The original signature.
--signature-format=&lt;raw|html|hex|cstr&gt;
      The format the signature is being passed in as. Default: hex.
-a --append=&lt;data&gt;
      The data to append to the string. Default: raw.
--append-format=&lt;raw|html|hex|cstr&gt;
-f --format=&lt;all|md4|md5|ripemd160|sha|sha1|sha256|sha512|whirlpool&gt; [REQUIRED]
      The hash_type of the signature. This can be given multiple times if you
      want to try multiple signatures. 'all' will base the chosen types off
      the size of the signature and use the hash(es) that make sense.
-l --secret=&lt;length&gt;
      The length of the secret, if known. Default: 8.
--secret-min=&lt;min&gt;
--secret-max=&lt;max&gt;
      Try different secret lengths (both options are required)

OUTPUT OPTIONS
--table
      Output the string in a table format.
--out-data-format=&lt;raw|html|html-pure|hex|cstr|cstr-pure|none&gt;
      Output data format.
--out-signature-format=&lt;raw|htmlhtml-pure||hex|cstr|cstr-pure|none&gt;
      Output signature format.

OTHER OPTIONS
-h --help 
      Display the usage (this).
--test
      Run the test suite.
-q --quiet
      Only output what's absolutely necessary (the output string and the
      signature)
</pre>

<h1>Defense</h1>

So, as a programmer, how do you solve this?

It's actually pretty simple. There are two ways:

<ol>
  <ul>Don't trust a user with encrypted data or signatures, if you can avoid it.</ul>
  <ul>If you can't avoid it, then use HMAC() instead of trying to do it yourself. HMAC is designed for this.</ul>
</ol>

HMAC() is the real solution. HMAC() is designed for securely hashing data based
on a secret key.

As usual, use constructs designed for what you're doing rather than doing it
yourself. The key to all crypto!

